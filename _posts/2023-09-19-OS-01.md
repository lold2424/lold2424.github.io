---
layout: single

title: "컴퓨터 시스템 개요"

date: 2023-09-19 20:00:00 +0900
lastmod: 2023-09-19 20:00:00 +0900 # sitemap.xml에서 사용됨

author_profile: true

header:
  overlay_image: 

  overlay_filter: 0.5 # 투명도

categories: 
  - College OS

tags: 
    - OS
    - College

# table of contents
toc: true # 오른쪽 부분에 목차를 자동 생성해준다.
toc_label: "table of content" # toc 이름 설정
toc_icon: "bars" # 아이콘 설정
toc_sticky: true # 마우스 스크롤과 함께 내려갈 것인지 설정
---
# 01 컴퓨터 시스템 개요

### 운영체제 주요 역할

- 사용자와 하드웨어 사이에서 사용자를 대신해 하드웨어를 효율적으로 사용할 수 있게 해준다.
1. 사용자 입장
    - 사용자 프로그램을 실행할 수 있고, 컴퓨터 시스템을 편리하게 사용 가능케 해줌
2. 시스템 입장
    - 시스템 자원의 관리를 수행 가능 하도록 해줌

### 컴퓨터란 무엇인가?

- 제어 하에 자동으로 동작하는 데이터 처리기
메인 메모리에 저장된 명령어 목록(프로그램이라고 함).

### 컴퓨터 시스템 구조

![](\assets\image\OS\01/Untitled.png)

- 컴퓨터 시스템의 4가지 구성 요소
    1. 하드웨어
        - 컴퓨터 자원을 제공
    2. 운영체제$$_{Operating\ System}$$
        - 다양한 응용프로그램 간의 하드웨어 사용을 제어하고 조정
    3. 응용 프로그램
        - 시스템 리소스 사용 방식 정의
    4. 사용자

### 컴퓨터 구조$$_{Computer \ Architecture}$$

- 컴퓨터 구조란?
    - 컴퓨터 시스템의 하드웨어 및 내부 구성 요소를 설계하고 구현하는 데 관련된 개념
    - 컴퓨터의 물리적인 부분과 이런 하드웨어 간 상호 작용 방식을 다룬다.
    - 즉, 내부적인 설계 뿐 아니라 외부적인 시스템과의 상호 작용도 고려하는 개념이라고 보면 된다.
- 속성
    - 명령어 집합
    - 레지스터
    - 데이터 표현 - 데이터 유형의 크기
    - 입출력 메커니즘
    - 주소 지정 기술

### 컴퓨터 조직$$_{Computer\ Organization}$$

- 컴퓨터 조직이란?
    - 컴퓨터가 더 빠르게 동작하기 위해 고려하는 회로의 설계 방식이다.
    - 아키텍처 사양을 실현하는 운영 단위와 그 상호 연결을 의미한다.
    - 하드웨어 컴포넌트 및 리소스의 물리적인 배치와 상호 연결을 다루는 것에 중점을 둔다.
- 속성
    - 제어 신호
    - 컴퓨터/주변기기 인터페이스
    - 메모리 기술
    - 클록 주파수
    - 물리적 메모리 크기

# 컴퓨터 하드웨어

- 아래 그림은 폰 노이만 구조다.
- 프로그램이 컴퓨터 메모리에 적재되어서 처리해주는 개념이다.

![](\assets\image\OS\01/Untitled 1.png)

- 컴퓨터는 프로그램 코드들을 정해진 순서대로 실행
    - 필요한 데이터를 읽어서, 처리하고, 저장

## 컴퓨터의 주요 구성 요소들

### 중앙처리장치$$_{CPU}$$

- 프로세서
- **프로그램 실행**과 **데이터 처리**라는 중추적인 기능의 수행을 담당
- 구성
    - 산술논리연산장치$$_{ALU}$$
        - 연산 원툴
    - 레지스터 세트$$_{Register \ Set}$$
        - 메모리에 있던 데이터를 임시로 저장해줌
    - 제어 장치$$_{Control \ Unit}$$
        - 레지스터와 연산장치를 제어하는 명령을 보냄(일방통행)
        명령을 보내는 프로그램은 아래와 같이 2개 있음
        1. 내부적 프로그램
            - CPU 내부 동작 제어
        2. 사용자 프로그램
            - 사용자의 작업을 처리하기 위함
    - 내부 버스
- 프로그램이 연속적으로, 순차적으로 동작하기 위해서 프로그램의 명령을 읽어들어야 하는데 이를 CPU가 해준다고 보면 된다.

### 산술 논리 연산장치$$_{ALU}$$

- 각종 산술 연산들과 논리 연산들을 수행하는 회로들로 이루어진 하드웨어 모듈
- 산술 연산(= 사칙 연산)
- 논리 연산(= AND, OR, NOT, XOR, …)

### 레지스터$$_{Register}$$

- 프로세서 내부에서 데이터를 **일시적으로 보관**하는 기억 장치
    - Flip-flop과 Latch 등의 디지털 회로로 구성
- 프로세서 레지스터의 종류
    - 범용 레지스터
        - 프로그램 또는 데이터 처리에 필요한 작업을 수행하기 위해서 사용
    - 제어용 레지스터
        - 프로그램이나 프로세서를 제어
        - 프로그램 카운터$$_{PC}$$ 등
    - 상태 레지스터
        - 프로세서의 상태를 나타낸다.

![](\assets\image\OS\01/Untitled 2.png)

### 제어장치$$_{CU}$$

- 프로그램 코드(명령어)를 해석하고, 실행하기 위한 제어 신호들을 순차적으로 발생하는 하드웨어 모듈
- 명령어 실행에 필요한 정보들의 전송 통로와 방향 지정
- CPU 내부 요소와 시스템 구성 요소들의 동작 시간 결정
    
    ![](\assets\image\OS\01/Untitled 3.png)
    

### 프로세서의 종류

- i386
    - 오랜 기간의 사용으로 안정성 확보
    - PC와 동일한 개발 환경 구성
- ARM
    - 간단한 명령어 사용하고, 개발 환경이 간단하다.
    - 전력 소모가 작아서 휴대폰(스마트폰)이나 임베디드시스템에서 많이 사용
- PowerPC
    - 이젠 사라져서 안 씀
    - 강력한 네트워크 기능을 포함한 SoC로 널리 알려짐
- M68K
    - 네트워크 장비 및 휴대 단말기에서 많이 사용
- MIPS
    - 고속의 처리 능력
    - 고속 네트워크 장비등에 많이 사용

### 기억장치$$_{Memory}$$

- CPU가 실행할 프로그램과 데이터를 저장하는 장치
- 주기억장치
    - 영구 저장 X
- 보조저장장치
    - 영구 저장 O

### 입출력장치

- 입력 장치$$_{Input \ device}$$
- 출력 장치$$_{Output \ device}$$

### 시스템버스

- 하드웨어를 물리적으로 연결해 서로 데이터를 주고받을 수 있게 하는 통로
- CPU, 주기억장치, I/O 간 통신

### 외부 버스$$_{external \ bus}$$

- 프로세서와 외부의 기억장치 사이, 그리고 프로세서와 I/O 장치 사이에 존
재하는 버스
    - 데이터 버스
    - 어드레스 버스
    - 제어 버스

## 메모리

- **메모리 계층 구조**
    - 1950~1960년대 너무 비싼 메인 메모리의 가격 문제 때문에 제안한 방법
    - 메모리를 계층적으로 구성하여 비용, 속도, 용량, 접근시간 등을 상호 보완

![](\assets\image\OS\01/Untitled 4.png)

- 캐시
    - 주 기억 장치와 cpu사이에 놓여있어 고속으로 동작
    - 레지스터는 속도가 빠르다 but, 메인 메모리는 그보다 느리다.
    이를 캐시가 보완해준다.
    - 캐시 히트: cash에서 원하는 데이터를 찾았을 경우
    - 캐시 미스: cash에서 원하는 데이터를 못 찾았을 경우
    - 캐시 미스가 많이 발생할수록 cpu의 동작속도는 메인 메모리에 비슷하게 낮아진다.
    - 캐시 히트가 많이 발생할수록 cpu의 동작속도는 캐시에 비슷하게 높아진다.

## 가상 메모리$$_{Virtual \ Memory}$$

**이거 중요함**

- **메인 메모리의 유효 크기를 늘리는 기법.**
- 보조 기억 장치에 프로그램이나 데이터를 저장했다 필요 시 다시 메인 메모리로 이동시키는 기술.
- 메인 메모리의 공간 부족으로 현재 실행 중인 프로그램이나 데이터를 저장 할 수 없을 때 가상 메모리를 이용해 프로그램과 데이터를 보조 기억 장치에 일부 저장한 후 필요 시 다시 메인 메모리로 옮겨 실행.
- 가상 메모리의 특징을 활용하기 위해 실행 중인 프로세스가 참조하는 주소와 메인 메모리에서 사용하는 주소를 분리해야 한다.
- 매핑(사상, $$Mapping$$), 메모리 맵$$_{Memory Map}$$: 논리적 주소를 물리적 주소로 변환하는 과정.
- 가상 메모리에 CPU는 접근할 수 없다.
    - 가상 메모리는 데이터를 가상 주소로 저장하기 때문!
    - 가상 주소를 매핑, 맵을 통해 물리적 주소로 변환해주는 MMU가 필요한 이유이기도 함.

![](\assets\image\OS\01/Untitled 5.png)

## 메모리 시스템 구조

![](\assets\image\OS\01/Untitled 6.png)
## MMU$$_{Memory \ Management \ Units}$$

- 어드레스 변환 기능
    - CPU에서 사용되는 logical 한 Virtual 어드레스를 physical 어드레스로 변환
- 메모리 보호 기능

# 컴퓨터 시스템의 동작

- 컴퓨터 시스템의 작업 처리 순서
    - 입력장치의 정보를 메모리에 저장
    - 메모리에 저장한 정보를 프로그램 제어에 따라 인출하여 연산장치에서 처
    리
    - 처리한 정보를 출력장치에 표시하거나 보조기억장치에 저장
- 명령어와 데이터
    - 입력장치로 컴퓨터에 유입되는 정보
    - 명령어는 실행할 산술·논리 연산의 동작을 명시하는 문장으로, 어떤 작업을 수행하는 명령어 집합이 프로그램
    - 프로그램은 컴파일러 등을 이용하여 0과 1로 이진화된 기계 명령어로 변환해야 컴퓨터가 이해할 수 있음

## 컴퓨터 부팅

- `bootstrap` 프로그램은 전원을 켜거나 재부팅시 불러온다.
    - 일반적으로 펌웨어로 알려진 ROM 또는 EPROM에 저장됨
        - 컴퓨터가 off했다 on되기 때문에 RAM에 저장하면 안됨!
    - 시스템의 모든 측면을 초기화한다
    - 운영 체제 커널을 로드하고 실행을 시작한다

## 현대의 컴퓨터 동작 방법

![](\assets\image\OS\01/Untitled 7.png)

- 메모리 → cpu: 읽기(인출)
- cpu → 메모리: 쓰기(저장)
- 양방향으로 이동
- CPU는 멀티 쓰레드기 때문에 N개가 존재
- DMA$$_{Direct \ Memory \ Access}$$: I/O 장치와 Memory가 데이터를 주고 받는 것
    - **CPU를 거치지 않고 바로 이동이 가능함**

### 현대의 시스템 구조

- 멀티프로그래밍
    - 1명의 사용자가 CPU와 I/O장치를 항상 사용하도록 유지할 수 없다
    - 멀티프로그래밍은 CPU가 실행할 작업을 항상 사용 가능하도록 해준다
    - 시스템의 모든 작업 중 일부만 메모리에 로드되며, 나머지는 디스크에 저장된다
    - 작업 스케줄링은 메모리에 로드된 작업 중 하나를 선택하고 실행한다
    - 작업이 I/O 작업을 기다려야 할 때, 운영체제는 다른 작업으로 전환하여 시스템 자원을 효율적으로 활용한다.
- 멀티태스킹$$_{Timesharing}$$
    - 멀티태스킹은 사용자가 여러 작업 간에 빠르게 전환하여 상호작용하는 환경을 만든다.
    - 응답 시간은 1초 미만이야 한다.
    - 각 사용자는 메모리에서 실행 중인 적어도 하나의 프로그램 or 프로세스를 갖는다.
    - 여러 작업 중 CPU에 할당될 작업을 선택한다.
    - 모든 작업이 메모리에 저장할 공간이 부족하면, 스와핑을 사용해 디스크, 메모리 간 이동시켜 실행
    - 가상 메모리는 모든 프로세스가 완전히 메모리에 로드되지 않아도 실행이 가능하다.

### 멀티프로그래밍 시스템을 위한 메모리 레이아웃

![](\assets\image\OS\01/Untitled 8.png)

효율적으로 실행, 관리가 가능하도록 층으로 나눔

### 기본적인 명령어 형식의 구성

- 가상 CPU 명령어 형식 정의 (예)
- 연산 코드$$_{operation \ code}$$
    - CPU가 수행할 연산을 지정
- 오퍼랜드$$_{operand}$$
    - 연산에 필요한 데이터 또는 데이터가 저장된 주소(위치)

![](\assets\image\OS\01/Untitled 9.png)

- 메모리에 저장된 명령어의 예
    - 명령어 실행
    
    ![](\assets\image\OS\01/Untitled 10.png)
    
- 실행 과정
    
    ![](\assets\image\OS\01/Untitled 11.png)
    

### 명령어 사이클

- CPU가 한 개의 명령어를 실행하는 데 필요한 전체 처리 과정
- CPU가 프로그램 실행을 시작한 순간부터 전원을 끄거나 회복 불가능한 오류가 발생하여 중단될 때까지 반복
    
    ![](\assets\image\OS\01/Untitled 12.png)
    
- 프로세서의 제어장치가 명령어를 실행
    - 인출 사이클$$_{fetch \ cycle}$$
        - 메모리에서 명령어를 읽어 레지스터에 저장, 다음 명령어를 실행시키기 위해 pc를 증가시킴
    - 실행 사이클$$_{execution \ cycle}$$
        - 인출한 명령어를 해독, 결과에 따른 제어 신호를 발생시켜 명령어 실행
- 메모리 간접 주소 지정 방법은 **데이터의 실제 주소를 기억장치에서 읽어 오는 간접 사이클을 사용하기도 함**
    - 간접 사이클$$_{indirect \ cycle}$$
        - 명령어 수행 전 실제 데이터가 저장된 주기억장치의 주소인 유효 주소를 한 번 더 읽음
    - 인터럽트 사이클$$_{interrupt \ cycle}$$
        - 인터럽트 발생시 방문

### 명령어 파이프라이닝

- CPU의 프로그램 처리 속도를 높이기 위해 CPU 내부 하드웨어를 여러 단계로 나눠 동시 처리하는 기술

### 2단계 명령어 파이프라인과 시간 흐름도

![](\assets\image\OS\01/Untitled 13.png)

- 명령어를 실행하는 하드웨어를 **인출, 실행 단계의 독립적인 파이프라인 모습**들로 분리
- 두 단계들에 동일한 클럭을 가해 동작 시간 일치
    1. 첫 번째 클럭 주기
        - 인출 단계가 첫 명령어를 인출
    2. 두 번째 클럭 주기
        - 인출된 첫 명령어가 실행
        - 인출 단계는 두 번째 명령어 인출
    3. 세 번째 클럭 주기
        - 두 번째 명령어 실행
        - 세 번째 명령어 인출
- 명령어 파이프라인의 장점
    - 명령어를 가져오고 싱행하는 단계가 끊임없이 계속 됨
    - 주어진 시간동안에 수행될 수 있는 명령어 수 증가

### 서브루틴들이 포함된 프로그램의 실행 과정

![](\assets\image\OS\01/Untitled 14.png)

### 컴퓨터 시스템 조직

- 하나 이상의 CPU와 장치 컨트롤러가 공통 버스를 통해 연결돼 공유 메모리에 접근
- CPU와 장치가 동시에 실행되며 메모리 사이클을 경쟁함
    - 메모리는 한정적인데 컴퓨터의 구조상 여러 부품들이 메모리를 사용해야 하기 때문

![](\assets\image\OS\01/Untitled 15.png)

- I/O 장치와 CPU는 동시에 실행될 수 있다.
- 각 장치 컨트롤러는 특정한 장치 유형을 담당한다.
- 각 장치 컨트롤러는 로컬 버퍼를 가지고 있다.
- CPU는 주 메모리와 로컬 버퍼 간에 데이터를 이동시킨다.
- I/O 작업은 장치에서 컨트롤러의 로컬 버퍼로 이뤄진다.
- 장치 컨트롤러는 작업을 완료했다는 알림을 CPU에게 **인터럽트를 발생**시켜 알린다.

### 인터럽트$$_{Interrupt}$$

- 인터럽트
    - 다른 모듈들 (I/O or 기억장치)이 프로세서의 정상적인 처리를 중단할 수
    있는 메커니즘
    - I/O 동작이 수행되는 동안에도 프로세서는 다른 명령어들을 실행
    - 즉, **처리 효율을 향상**
- 프로그램 실행 중에 CPU의 현재 처리 순서를 중단시키고 다른 동작을
수행하도록 하는 것
- 외부로부터 인터럽트 요구가 들어오면,
    - CPU는 원래의 프로그램 수행을 중단하고,
    - 요구된 인터럽트를 위한 서비스 프로그램을 먼저 수행
- 인터럽트 서비스 루틴$$_{interrupt \ service \ routine: ISR}$$
    - 인터럽트를 처리하기 위하여 수행하는 프로그램 루틴

### 인터럽트 종류

- 프로그램
- 타이머
- 입/출력
- 하드웨어
- 트랩$$_{Trap}$$: 오류 또는 사용자 요청에 의해 발생하는 소프트웨어 생성 인터럽트다.
- 운영 체제는 인터럽트에 의해 동작한다.

### I/O 장치의 접속

- I/O 장치
    - 사용자 또는 외부와 정보 교환을 위한 장치, 주변장치
    - 보조저장장치: 디스크 드라이브, 자기테이프, CD-ROM
    - 그래픽 디스플레이 터미널, 프린터 등
- I/O 모듈이란?
    - 프로세서 & 기억장치 모듈와 함께 컴퓨터 시스템을 구성하는 요소
    - 시스템 버스와의 인터페이스 역할 뿐만 아니라, 하나 혹은 그 이상의 주변
    장치들을 제어
    
    ![](\assets\image\OS\01/Untitled 16.png)
    

### I/O 기법

- 프로그램 I/O
- 인터럽트 구동 I/O
- DMA

![](\assets\image\OS\01/Untitled 17.png)

### I/O 제어

- I/O 장치의 동작
    - 시스템 버스를 통하여 CPU/주기억장치와 정보 교환
- **I/O 장치가 시스템 버스에 직접 접속되지 못하는 이유**
    - I/O 장치들은 종류에 따라 제어 방법이 서로 다름
    - 제어 회로들을 CPU 내부에 모두 포함시키는 것이 불가능하기 때문에
    CPU가 직접 제어 불가능
    - I/O 장치들의 데이터 전송 속도 << CPU의 데이터 처리 속도
        - 고속의 시스템 버스와 I/O 장치들 사이에 직접 데이터 교환 불가능
    - I/O 장치와 CPU 데이터 형식의 길이가 서로 다른 경우가 많음
        - **인터페이스 장치인 I/O 제어기$$_{I/O \ controller}$$$$를 사용**
- I/O 제어기의 주요 기능
    - I/O 장치의 제어와 타이밍 조정
    - CPU와의 통신 담당
    - I/O 장치와의 통신 담당
    - 데이터 버퍼링$$_{data \ buffering}$$
    - 오류 검출

### 직접 기억장치 액세스$$_{DMA}$$

- 인터럽트 구동 I/O 방식
    - 프로그램 I/O 방식 보다 효율적
    - **기억장치 $$↔$$ I/O 장치 데이터 이동에는 CPU 개입**
        - 주기억장치 $$→$$ I/O 장치 데이터 이동
            - CPU(레지스터) $$←$$ 주기억장치
            - CPU(레지스터) $$→$$ I/O장치: 데이터
            - CPU(레지스터) $$→$$ I/O장치: I/O 명령
- Direct Memory Access = DMA
    - CPU의 개입 없이 I/O 장치와 기억장치 사이에 데이터를 전송하는 방식
    - 방법
        - DMA 제어기 사용
        - 사이클 훔침$$_{cycle \ stealing}$$
            - CPU가 주 기억장치를 액세스하지 않는 시간(CPU가 내부적으로 명령어를 해독하거나 ALU 연산을 수행하는 시간) 동안에 시스템 버스를 사용
            - 위 사이클 동안 모든 블록 전송 불가능 $$→$$ I/O 시간 증가
        - 큰 데이터 블록의 전송
            - DMA 제어기가 시스템 버스 사용 요청 $$→$$ CPU가 승인, 블록단위 전송(CPU는 대기)

### DMA 제어기가 포함된 시스템 구성도

![](\assets\image\OS\01/Untitled 18.png)